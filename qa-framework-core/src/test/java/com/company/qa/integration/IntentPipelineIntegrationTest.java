package com.company.qa.integration;

import com.company.qa.model.intent.IntentActionType;
import com.company.qa.model.intent.TestIntent;
import com.company.qa.service.playwright.FrameworkCapabilityService;
import com.company.qa.service.playwright.PlaywrightJavaRenderer;
import com.company.qa.service.playwright.TestIntentParser;
import com.company.qa.service.playwright.TestIntentParser.ParseResult;
import com.company.qa.service.playwright.TestIntentValidator;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.*;
import org.springframework.test.util.ReflectionTestUtils;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration test for the complete Zero-Hallucination pipeline.
 *
 * Wires REAL service instances (no mocks, no Spring context):
 *   TestIntentParser → TestIntentValidator → PlaywrightJavaRenderer
 *
 * Tests the full pipeline: raw JSON → parsed intent → validated → rendered Java.
 *
 * SCOPE:
 *   - Parser correctly handles valid, wrapped, invalid, and legacy formats
 *   - Validator enforces all 11 rules before rendering is ever attempted
 *   - Renderer produces correct Playwright API calls for all 9 locator strategies
 *   - Rendered Java never contains hallucinated calls (Playwright.create, Thread.sleep, etc.)
 *   - Pipeline is idempotent — same input always produces same output
 *   - FrameworkCapabilityService exposes all 24 action types in its prompt text
 *
 * COMPILATION NOTE:
 *   The generated Java is verified structurally (contains correct strings) NOT via
 *   javax.tools.JavaCompiler — that compilation step happens in the E2E test
 *   (Week16Day5CompleteE2ETest) once the full classpath (including BasePlaywrightTest)
 *   is available. This test runs standalone with zero Spring startup.
 *
 * @since Zero-Hallucination Pipeline — Week 2, Day 3
 */
@DisplayName("Intent Pipeline — End-to-End Integration (No Spring)")
class IntentPipelineIntegrationTest {

    // ─── Real service instances — wired manually ──────────────────────
    private ObjectMapper          objectMapper;
    private TestIntentValidator   validator;
    private TestIntentParser      parser;
    private PlaywrightJavaRenderer renderer;
    private FrameworkCapabilityService capabilityService;

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();
        validator    = new TestIntentValidator();
        parser       = new TestIntentParser(objectMapper, validator);

        renderer = new PlaywrightJavaRenderer();
        ReflectionTestUtils.setField(renderer, "baseClass",
                "com.company.qa.playwright.BasePlaywrightTest");
        ReflectionTestUtils.setField(renderer, "basePackage",
                "com.company.qa.playwright.generated");
        ReflectionTestUtils.setField(renderer, "addDisplayName", true);
        ReflectionTestUtils.setField(renderer, "addStepComments", true);

        capabilityService = new FrameworkCapabilityService();
        ReflectionTestUtils.setField(capabilityService, "baseClass",
                "com.company.qa.playwright.BasePlaywrightTest");
        ReflectionTestUtils.setField(capabilityService, "basePackage",
                "com.company.qa.playwright.generated");
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 1: Sauce Demo Login — full pipeline golden test
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("Sauce Demo Login — golden path")
    class SauceDemoLoginFlow {

        @Test
        @DisplayName("Valid login intent produces compilable Java class")
        void loginIntentProducesValidJava() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());

            assertThat(result.isSuccess())
                    .as("Parse should succeed: %s", result.getSummary())
                    .isTrue();

            TestIntent intent = result.getIntent();
            assertThat(intent.getTestClassName()).isEqualTo("PROJ123_LoginTest");
            assertThat(intent.getScenarioCount()).isEqualTo(2);

            String java = renderer.render(intent);

            // ── Class structure ─────────────────────────────────────────
            assertThat(java).startsWith("package com.company.qa.playwright.generated;");
            assertThat(java).contains(
                    "public class PROJ123_LoginTest extends BasePlaywrightTest");
            assertThat(java).contains("Auto-generated by Zero-Hallucination Pipeline");

            // ── Correct Playwright API calls — no hallucinations ─────────
            assertThat(java).contains("page.navigate(\"https://www.saucedemo.com\")");
            assertThat(java).contains("page.getByTestId(\"username\").fill(\"standard_user\")");
            assertThat(java).contains("page.getByTestId(\"password\").fill(\"secret_sauce\")");
            assertThat(java).contains("page.getByTestId(\"login-button\").click()");
            assertThat(java).contains(
                    "assertThat(page).hasURL(Pattern.compile(\".*inventory.*\"))");

            // ── Negative scenario rendered ───────────────────────────────
            assertThat(java).contains("testInvalidCredentialsShowsError");
            assertThat(java).contains(
                    "assertThat(page.locator(\".error-message-container\")).isVisible()");

            // ── CRITICAL: no hallucinated Java ───────────────────────────
            assertThat(java).doesNotContain("Playwright.create()");
            assertThat(java).doesNotContain("Thread.sleep");
            assertThat(java).doesNotContain("BrowserType");
            assertThat(java).doesNotContain("import com.microsoft.playwright.Playwright;");
            assertThat(java).doesNotContain("import com.microsoft.playwright.Browser;");
            assertThat(java).doesNotContain("import com.microsoft.playwright.BrowserType;");

            // ── Required imports present ─────────────────────────────────
            assertThat(java).contains("import org.junit.jupiter.api.Test;");
            assertThat(java).contains(
                    "import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;");
            assertThat(java).contains("import java.util.regex.Pattern;");
            assertThat(java).contains("import com.microsoft.playwright.options.AriaRole;");

            // ── Extends BasePlaywrightTest (compilation prerequisite) ────
            assertThat(java).contains("extends BasePlaywrightTest");

            // ── Valid Java ending ────────────────────────────────────────
            assertThat(java.stripTrailing()).endsWith("}");
        }

        @Test
        @DisplayName("Login intent passes validation with zero errors")
        void loginIntentPassesValidation() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            assertThat(result.isSuccess()).isTrue();
            assertThat(result.getValidation().getErrors()).isEmpty();
        }

        @Test
        @DisplayName("Login intent: both scenarios become @Test methods")
        void loginBothScenariosBecomeMethods() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            String java = renderer.render(result.getIntent());

            long testMethodCount = java.lines()
                    .filter(line -> line.trim().equals("@Test"))
                    .count();
            assertThat(testMethodCount).isEqualTo(2);
        }

        @Test
        @DisplayName("Login intent: step descriptions become inline comments")
        void loginDescriptionsRenderedAsComments() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            String java = renderer.render(result.getIntent());

            assertThat(java).contains("// Open Sauce Demo login page");
            assertThat(java).contains("// Enter username");
            assertThat(java).contains("// Verify redirect to products page");
        }

        @Test
        @DisplayName("Login intent: @DisplayName annotation rendered from scenario description")
        void loginDisplayNameRendered() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            String java = renderer.render(result.getIntent());

            // scenario description → @DisplayName
            assertThat(java).contains("@DisplayName");
            assertThat(java).contains("Standard user logs in");
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 2: Sauce Demo Checkout — multi-scenario, multi-assertion
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("Sauce Demo Checkout — multi-scenario")
    class SauceDemoCheckoutFlow {

        @Test
        @DisplayName("Checkout intent with 3 scenarios renders all methods")
        void checkoutThreeScenariosAllRendered() {
            ParseResult result = parser.parse(sauceDemoCheckoutIntentJson());

            assertThat(result.isSuccess())
                    .as("Parse should succeed: %s", result.getSummary())
                    .isTrue();

            TestIntent intent = result.getIntent();
            assertThat(intent.getScenarioCount()).isEqualTo(3);
            assertThat(intent.getTotalStepCount()).isGreaterThan(10);

            String java = renderer.render(intent);

            assertThat(java).contains("testAddProductToCart");
            assertThat(java).contains("testCompleteCheckout");
            assertThat(java).contains("testCartBadgeUpdates");

            assertThat(java).contains(
                    "page.getByTestId(\"add-to-cart-sauce-labs-backpack\").click()");
            assertThat(java).contains(
                    "assertThat(page.locator(\".cart_badge\")).hasText(\"1\")");
            assertThat(java).contains(
                    "assertThat(page.locator(\".complete-header\")).isVisible()");

            // No hallucinations in checkout either
            assertThat(java).doesNotContain("Playwright.create()");
            assertThat(java).doesNotContain("Thread.sleep");
        }

        @Test
        @DisplayName("ASSERT_COUNT action renders as hasCount(int)")
        void assertCountRenderedCorrectly() {
            ParseResult result = parser.parse(sauceDemoCheckoutIntentJson());
            String java = renderer.render(result.getIntent());
            assertThat(java).contains("assertThat(page.locator(\".inventory_item\")).hasCount(6)");
        }

        @Test
        @DisplayName("SELECT_OPTION action renders as selectOption()")
        void selectOptionRenderedCorrectly() {
            ParseResult result = parser.parse(sauceDemoCheckoutIntentJson());
            String java = renderer.render(result.getIntent());
            assertThat(java).contains(".selectOption(");
        }

        @Test
        @DisplayName("FILL action with LABEL locator renders as getByLabel().fill()")
        void fillWithLabelLocatorRendered() {
            ParseResult result = parser.parse(sauceDemoCheckoutIntentJson());
            String java = renderer.render(result.getIntent());
            // firstName uses label= locator in checkout intent
            assertThat(java).contains("page.getByLabel(\"First Name\").fill(\"Test\")");
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 3: Locator strategy rendering — all 9 strategies
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("Locator strategy rendering — all 9 strategies")
    class LocatorStrategyRendering {

        @Test
        @DisplayName("testid= renders as page.getByTestId()")
        void testIdLocatorRendered() {
            String java = renderSingleStep("CLICK", "testid=login-button", null);
            assertThat(java).contains("page.getByTestId(\"login-button\").click()");
        }

        @Test
        @DisplayName("role=button[name='X'] renders as page.getByRole(AriaRole.BUTTON, ...).setName()")
        void roleLocatorRendered() {
            String java = renderSingleStep("CLICK", "role=button[name='Login']", null);
            assertThat(java).contains("page.getByRole(AriaRole.BUTTON");
            assertThat(java).contains("setName(\"Login\")");
        }

        @Test
        @DisplayName("label= renders as page.getByLabel()")
        void labelLocatorRendered() {
            String java = renderSingleStep("FILL", "label=Email Address", "user@example.com");
            assertThat(java).contains("page.getByLabel(\"Email Address\").fill(\"user@example.com\")");
        }

        @Test
        @DisplayName("text= renders as page.getByText()")
        void textLocatorRendered() {
            String java = renderSingleStep("ASSERT_VISIBLE", "text=Products", null);
            assertThat(java).contains("page.getByText(\"Products\")");
        }

        @Test
        @DisplayName("css= renders as page.locator()")
        void cssLocatorRendered() {
            String java = renderSingleStep("ASSERT_VISIBLE", "css=.inventory_list", null);
            assertThat(java).contains("page.locator(\".inventory_list\")");
        }

        @Test
        @DisplayName("xpath= renders as page.locator() with xpath= prefix")
        void xpathLocatorRendered() {
            String java = renderSingleStep("CLICK", "xpath=//button[@id='submit']", null);
            assertThat(java).contains("page.locator(\"xpath=//button[@id='submit']\")");
        }

        @Test
        @DisplayName("id= renders as page.locator() with # prefix")
        void idLocatorRendered() {
            String java = renderSingleStep("CLICK", "id=username", null);
            assertThat(java).contains("page.locator(\"#username\")");
        }

        @Test
        @DisplayName("name= renders as page.locator() with [name='...'] selector")
        void nameLocatorRendered() {
            String java = renderSingleStep("FILL", "name=q", "search term");
            assertThat(java).contains("page.locator(\"[name='q']\").fill(\"search term\")");
        }

        @Test
        @DisplayName("class= renders as page.locator() with . prefix")
        void classLocatorRendered() {
            String java = renderSingleStep("ASSERT_VISIBLE", "class=error-message-container", null);
            assertThat(java).contains("page.locator(\".error-message-container\")");
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 4: Action type rendering — key assertions
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("Action type rendering — key action types")
    class ActionTypeRendering {

        @Test
        @DisplayName("NAVIGATE renders as page.navigate(url)")
        void navigateRendered() {
            String java = renderSingleStep("NAVIGATE", null, "https://www.saucedemo.com");
            assertThat(java).contains("page.navigate(\"https://www.saucedemo.com\")");
        }

        @Test
        @DisplayName("FILL renders as locator.fill(value)")
        void fillRendered() {
            String java = renderSingleStep("FILL", "testid=username", "standard_user");
            assertThat(java).contains(".fill(\"standard_user\")");
        }

        @Test
        @DisplayName("CLICK renders as locator.click()")
        void clickRendered() {
            String java = renderSingleStep("CLICK", "testid=login-button", null);
            assertThat(java).contains(".click()");
        }

        @Test
        @DisplayName("ASSERT_TEXT renders as assertThat(locator).hasText()")
        void assertTextRendered() {
            String java = renderSingleStep("ASSERT_TEXT", "css=.title", "Products");
            assertThat(java).contains("assertThat(page.locator(\".title\")).hasText(\"Products\")");
        }

        @Test
        @DisplayName("ASSERT_URL renders as assertThat(page).hasURL(Pattern.compile())")
        void assertUrlRendered() {
            String java = renderSingleStep("ASSERT_URL", null, ".*inventory.*");
            assertThat(java).contains("assertThat(page).hasURL(Pattern.compile(\".*inventory.*\"))");
        }

        @Test
        @DisplayName("ASSERT_VISIBLE renders as assertThat(locator).isVisible()")
        void assertVisibleRendered() {
            String java = renderSingleStep("ASSERT_VISIBLE", "css=.cart_badge", null);
            assertThat(java).contains("assertThat(page.locator(\".cart_badge\")).isVisible()");
        }

        @Test
        @DisplayName("ASSERT_COUNT renders as assertThat(locator).hasCount(int)")
        void assertCountRendered() {
            String java = renderSingleStep("ASSERT_COUNT", "css=.inventory_item", "6");
            assertThat(java).contains("assertThat(page.locator(\".inventory_item\")).hasCount(6)");
        }

        @Test
        @DisplayName("DOUBLE_CLICK renders as locator.dblclick()")
        void doubleClickRendered() {
            String java = renderSingleStep("DOUBLE_CLICK", "testid=item", null);
            assertThat(java).contains(".dblclick()");
        }

        @Test
        @DisplayName("HOVER renders as locator.hover()")
        void hoverRendered() {
            String java = renderSingleStep("HOVER", "testid=menu-item", null);
            assertThat(java).contains(".hover()");
        }

        @Test
        @DisplayName("PRESS_KEY renders as page.keyboard.press(key)")
        void pressKeyRendered() {
            String java = renderSingleStep("PRESS_KEY", null, "Enter");
            assertThat(java).contains("page.keyboard().press(\"Enter\")");
        }

        @Test
        @DisplayName("SCROLL renders as locator.scrollIntoViewIfNeeded()")
        void scrollRendered() {
            String java = renderSingleStep("SCROLL", "css=.footer", null);
            assertThat(java).contains(".scrollIntoViewIfNeeded()");
        }

        @Test
        @DisplayName("WAIT_FOR_SELECTOR renders as locator.waitFor()")
        void waitForSelectorRendered() {
            String java = renderSingleStep("WAIT_FOR_SELECTOR", "css=.inventory_list", null);
            assertThat(java).contains(".waitFor()");
        }

        @Test
        @DisplayName("WAIT_FOR_URL renders as page.waitForURL(pattern)")
        void waitForUrlRendered() {
            String java = renderSingleStep("WAIT_FOR_URL", null, ".*inventory.*");
            assertThat(java).contains("page.waitForURL(Pattern.compile(\".*inventory.*\"))");
        }

        @Test
        @DisplayName("SELECT_OPTION renders as locator.selectOption(value)")
        void selectOptionRendered() {
            String java = renderSingleStep("SELECT_OPTION", "testid=sort-container",
                    "Name (A to Z)");
            assertThat(java).contains(".selectOption(\"Name (A to Z)\")");
        }

        @Test
        @DisplayName("SCREENSHOT renders as page.screenshot()")
        void screenshotRendered() {
            String java = renderSingleStep("SCREENSHOT", null, "login-page");
            assertThat(java).contains("page.screenshot(");
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 5: Timeout handling
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("Timeout handling")
    class TimeoutHandling {

        @Test
        @DisplayName("Step with timeout inserts waitFor before action")
        void timeoutInsertsWaitFor() {
            String json = intentJson("CLICK", "testid=slow-btn", null, 5000);
            ParseResult result = parser.parse(json);
            String java = renderer.render(result.getIntent());
            // timeout → waitFor before the click
            assertThat(java).contains("waitFor(");
            assertThat(java).contains("5000");
        }

        @Test
        @DisplayName("Step without timeout has no explicit waitFor")
        void noTimeoutNoWaitFor() {
            String java = renderSingleStep("CLICK", "testid=fast-btn", null);
            assertThat(java).doesNotContain("waitFor(");
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 6: Import management — only include what is used
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("Import management — conditional imports")
    class ImportManagement {

        @Test
        @DisplayName("Pattern imported only when ASSERT_URL or WAIT_FOR_URL present")
        void patternImportedOnlyWhenNeeded() {
            // has ASSERT_URL → needs Pattern
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            String java = renderer.render(result.getIntent());
            assertThat(java).contains("import java.util.regex.Pattern;");
        }

        @Test
        @DisplayName("AriaRole imported only when role= locator present")
        void ariaRoleImportedOnlyWhenNeeded() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            String java = renderer.render(result.getIntent());
            // login intent has role= locator
            assertThat(java).contains("import com.microsoft.playwright.options.AriaRole;");
        }

        @Test
        @DisplayName("assertThat imported only when assertion steps present")
        void assertThatImportedOnlyWhenNeeded() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            String java = renderer.render(result.getIntent());
            assertThat(java).contains(
                    "import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;");
        }

        @Test
        @DisplayName("Playwright, Browser, BrowserType never imported")
        void lifecycleImportsNeverPresent() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            String java = renderer.render(result.getIntent());

            assertThat(java).doesNotContain("import com.microsoft.playwright.Playwright;");
            assertThat(java).doesNotContain("import com.microsoft.playwright.Browser;");
            assertThat(java).doesNotContain("import com.microsoft.playwright.BrowserType;");
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 7: Validation — all error paths caught before rendering
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("Validation — errors caught before rendering")
    class ValidationErrorPaths {

        @Test
        @DisplayName("Scenario with no assertions → VALIDATION_FAILURE")
        void noAssertionsIsValidationFailure() {
            String json = """
                    {
                      "testClassName": "BadTest",
                      "scenarios": [{
                        "name": "testBad",
                        "steps": [
                          {"action": "NAVIGATE", "value": "https://example.com"},
                          {"action": "CLICK", "locator": "testid=btn"}
                        ]
                      }]
                    }
                    """;
            ParseResult result = parser.parse(json);
            assertThat(result.isValidationFailure()).isTrue();
            assertThat(result.getValidation().getErrors())
                    .anyMatch(e -> e.toLowerCase().contains("assert"));
        }

        @Test
        @DisplayName("Java code in locator field → VALIDATION_FAILURE")
        void javaCodeInLocatorRejected() {
            String json = """
                    {
                      "testClassName": "BadLocatorTest",
                      "scenarios": [{
                        "name": "testBad",
                        "steps": [
                          {"action": "CLICK",
                           "locator": "page.locator('[data-test=btn]')"},
                          {"action": "ASSERT_URL", "value": ".*"}
                        ]
                      }]
                    }
                    """;
            ParseResult result = parser.parse(json);
            assertThat(result.isValidationFailure()).isTrue();
            assertThat(result.getValidation().getErrors())
                    .anyMatch(e -> e.toLowerCase().contains("java code")
                            || e.toLowerCase().contains("locator"));
        }

        @Test
        @DisplayName("Thread.sleep in locator → VALIDATION_FAILURE")
        void threadSleepInLocatorRejected() {
            String json = """
                    {
                      "testClassName": "SleepTest",
                      "scenarios": [{
                        "name": "testBad",
                        "steps": [
                          {"action": "CLICK",
                           "locator": "Thread.sleep(1000)"},
                          {"action": "ASSERT_URL", "value": ".*"}
                        ]
                      }]
                    }
                    """;
            ParseResult result = parser.parse(json);
            assertThat(result.isValidationFailure()).isTrue();
        }

        @Test
        @DisplayName("FILL without locator → VALIDATION_FAILURE")
        void fillWithoutLocatorRejected() {
            String json = """
                    {
                      "testClassName": "MissingLocatorTest",
                      "scenarios": [{
                        "name": "testBad",
                        "steps": [
                          {"action": "FILL", "value": "some text"},
                          {"action": "ASSERT_URL", "value": ".*"}
                        ]
                      }]
                    }
                    """;
            ParseResult result = parser.parse(json);
            assertThat(result.isValidationFailure()).isTrue();
        }

        @Test
        @DisplayName("NAVIGATE without value → VALIDATION_FAILURE")
        void navigateWithoutValueRejected() {
            String json = """
                    {
                      "testClassName": "MissingValueTest",
                      "scenarios": [{
                        "name": "testBad",
                        "steps": [
                          {"action": "NAVIGATE", "locator": "testid=something"},
                          {"action": "ASSERT_URL", "value": ".*"}
                        ]
                      }]
                    }
                    """;
            ParseResult result = parser.parse(json);
            assertThat(result.isValidationFailure()).isTrue();
        }

        @Test
        @DisplayName("Unknown action type → PARSE_ERROR")
        void unknownActionTypeIsParseError() {
            String json = """
                    {
                      "testClassName": "BadActionTest",
                      "scenarios": [{
                        "name": "testBad",
                        "steps": [
                          {"action": "EXPLODE_EVERYTHING", "value": "boom"},
                          {"action": "ASSERT_URL", "value": ".*"}
                        ]
                      }]
                    }
                    """;
            ParseResult result = parser.parse(json);
            assertThat(result.isParseError()).isTrue();
        }

        @Test
        @DisplayName("Completely malformed JSON → PARSE_ERROR")
        void malformedJsonIsParseError() {
            ParseResult result = parser.parse("{not valid json at all }{{{");
            assertThat(result.isParseError()).isTrue();
        }

        @Test
        @DisplayName("Empty scenarios list → VALIDATION_FAILURE")
        void emptyScenariosRejected() {
            String json = """
                    {
                      "testClassName": "EmptyTest",
                      "scenarios": []
                    }
                    """;
            ParseResult result = parser.parse(json);
            assertThat(result.isValidationFailure()).isTrue();
        }

        @Test
        @DisplayName("Duplicate scenario names → VALIDATION_FAILURE")
        void duplicateScenarioNamesRejected() {
            String json = """
                    {
                      "testClassName": "DuplicateTest",
                      "scenarios": [
                        {"name": "testSame", "steps": [
                          {"action": "NAVIGATE", "value": "https://x.com"},
                          {"action": "ASSERT_URL", "value": ".*"}
                        ]},
                        {"name": "testSame", "steps": [
                          {"action": "NAVIGATE", "value": "https://y.com"},
                          {"action": "ASSERT_URL", "value": ".*"}
                        ]}
                      ]
                    }
                    """;
            ParseResult result = parser.parse(json);
            assertThat(result.isValidationFailure()).isTrue();
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 8: Format detection — parser correctly classifies responses
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("Format detection")
    class FormatDetection {

        @Test
        @DisplayName("Legacy Java-in-JSON response → NOT_INTENT (correct fallback signal)")
        void legacyJavaResponseIsNotIntent() {
            String legacy = """
                    {
                      "testClassName": "LoginTest",
                      "testClass": "public class LoginTest extends BasePlaywrightTest { @Test void test(){} }"
                    }
                    """;
            ParseResult result = parser.parse(legacy);
            assertThat(result.isNotIntent()).isTrue();
        }

        @Test
        @DisplayName("Intent JSON has 'scenarios' key → isIntentFormat() = true")
        void intentFormatDetectedByScenariosKey() {
            assertThat(parser.isIntentFormat(sauceDemoLoginIntentJson())).isTrue();
        }

        @Test
        @DisplayName("Legacy JSON has no 'scenarios' key → isIntentFormat() = false")
        void legacyFormatNotDetectedAsIntent() {
            String legacy = """
                    {"testClassName": "T", "testClass": "public class T {}"}
                    """;
            assertThat(parser.isIntentFormat(legacy)).isFalse();
        }

        @Test
        @DisplayName("Null/empty string → isIntentFormat() = false (no NPE)")
        void nullAndEmptyAreNotIntent() {
            assertThat(parser.isIntentFormat(null)).isFalse();
            assertThat(parser.isIntentFormat("")).isFalse();
            assertThat(parser.isIntentFormat("   ")).isFalse();
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 9: AI output wrapping — parser unwraps correctly
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("AI output wrapping — outer object unwrapped")
    class AIWrappingUnwrapping {

        @Test
        @DisplayName("Intent nested in 'testCode' key → unwrapped and parsed")
        void intentInTestCodeKeyUnwrapped() {
            String wrapped = """
                    {
                      "jiraStory": "PROJ-123",
                      "confidence": 0.95,
                      "testCode": %s
                    }
                    """.formatted(minimalValidIntentJson());

            ParseResult result = parser.parse(wrapped);
            assertThat(result.isSuccess())
                    .as("Wrapped intent should be unwrapped: %s", result.getSummary())
                    .isTrue();
            assertThat(result.getIntent().getTestClassName()).isEqualTo("LoginTest");
        }

        @Test
        @DisplayName("Extra unknown fields on intent/step/scenario → silently ignored")
        void extraUnknownFieldsIgnored() {
            String withExtras = """
                    {
                      "testClassName": "LoginTest",
                      "aiModel": "claude-sonnet",
                      "generationTime": 1234,
                      "scenarios": [{
                        "name": "testLogin",
                        "extraAnnotation": "ignored",
                        "steps": [
                          {"action": "NAVIGATE",
                           "value": "https://saucedemo.com",
                           "unknownField": "alsoIgnored"},
                          {"action": "ASSERT_URL", "value": ".*saucedemo.*"}
                        ]
                      }]
                    }
                    """;
            ParseResult result = parser.parse(withExtras);
            assertThat(result.isSuccess()).isTrue();
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 10: Idempotency & quality gates
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("Idempotency and quality gates")
    class IdempotencyAndQuality {

        @Test
        @DisplayName("Pipeline is idempotent — same input always produces same Java")
        void pipelineIsIdempotent() {
            String json = sauceDemoLoginIntentJson();
            ParseResult r1 = parser.parse(json);
            ParseResult r2 = parser.parse(json);

            assertThat(r1.isSuccess()).isTrue();
            assertThat(r2.isSuccess()).isTrue();

            String java1 = renderer.render(r1.getIntent());
            String java2 = renderer.render(r2.getIntent());

            assertThat(java1).isEqualTo(java2);
        }

        @Test
        @DisplayName("Rendered Java length > 800 chars (non-trivial output)")
        void renderedJavaIsSubstantial() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            String java = renderer.render(result.getIntent());
            assertThat(java.length()).isGreaterThan(800);
        }

        @Test
        @DisplayName("Login intent: exactly 2 @Test annotations in rendered Java")
        void correctNumberOfTestAnnotations() {
            ParseResult result = parser.parse(sauceDemoLoginIntentJson());
            String java = renderer.render(result.getIntent());
            long count = java.lines()
                    .filter(line -> line.trim().equals("@Test"))
                    .count();
            assertThat(count).isEqualTo(2);
        }

        @Test
        @DisplayName("Checkout intent: exactly 3 @Test annotations in rendered Java")
        void checkoutHasThreeTestAnnotations() {
            ParseResult result = parser.parse(sauceDemoCheckoutIntentJson());
            String java = renderer.render(result.getIntent());
            long count = java.lines()
                    .filter(line -> line.trim().equals("@Test"))
                    .count();
            assertThat(count).isEqualTo(3);
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // GROUP 11: FrameworkCapabilityService — prompt text correctness
    // ════════════════════════════════════════════════════════════════════

    @Nested
    @DisplayName("FrameworkCapabilityService — prompt text")
    class CapabilityServiceTests {

        @Test
        @DisplayName("All 24 action types mentioned in capabilities prompt")
        void allActionTypesInCapabilities() {
            String capabilities = capabilityService.getCapabilitiesForPrompt();
            for (IntentActionType actionType : IntentActionType.values()) {
                assertThat(capabilities)
                        .as("Capability prompt should mention: %s", actionType.name())
                        .contains(actionType.name());
            }
        }

        @Test
        @DisplayName("All 9 locator strategy examples in capabilities prompt")
        void allLocatorStrategiesInCapabilities() {
            String capabilities = capabilityService.getCapabilitiesForPrompt();
            assertThat(capabilities).contains("testid=");
            assertThat(capabilities).contains("role=");
            assertThat(capabilities).contains("label=");
            assertThat(capabilities).contains("text=");
            assertThat(capabilities).contains("css=");
            assertThat(capabilities).contains("xpath=");
            assertThat(capabilities).contains("id=");
            assertThat(capabilities).contains("name=");
            assertThat(capabilities).contains("class=");
        }

        @Test
        @DisplayName("BasePlaywrightTest class reference present in capabilities prompt")
        void baseClassInCapabilities() {
            String capabilities = capabilityService.getCapabilitiesForPrompt();
            assertThat(capabilities).contains("BasePlaywrightTest");
        }

        @Test
        @DisplayName("Capabilities prompt is non-empty and substantial")
        void capabilitiesPromptIsSubstantial() {
            String capabilities = capabilityService.getCapabilitiesForPrompt();
            assertThat(capabilities).isNotBlank();
            assertThat(capabilities.length()).isGreaterThan(500);
        }
    }

    // ════════════════════════════════════════════════════════════════════
    // Test data — canonical Sauce Demo intent JSONs
    // ════════════════════════════════════════════════════════════════════

    private String sauceDemoLoginIntentJson() {
        return """
                {
                  "testClassName": "PROJ123_LoginTest",
                  "baseUrl": "https://www.saucedemo.com",
                  "scenarios": [
                    {
                      "name": "testSuccessfulLogin",
                      "description": "Standard user logs in and sees the products page",
                      "tags": ["smoke", "login"],
                      "steps": [
                        {
                          "action": "NAVIGATE",
                          "value": "https://www.saucedemo.com",
                          "description": "Open Sauce Demo login page"
                        },
                        {
                          "action": "FILL",
                          "locator": "testid=username",
                          "value": "standard_user",
                          "description": "Enter username"
                        },
                        {
                          "action": "FILL",
                          "locator": "testid=password",
                          "value": "secret_sauce",
                          "description": "Enter password"
                        },
                        {
                          "action": "CLICK",
                          "locator": "testid=login-button",
                          "description": "Click login button"
                        },
                        {
                          "action": "ASSERT_URL",
                          "value": ".*inventory.*",
                          "description": "Verify redirect to products page"
                        },
                        {
                          "action": "ASSERT_VISIBLE",
                          "locator": "role=button[name='Open Menu']",
                          "description": "Verify hamburger menu visible"
                        }
                      ]
                    },
                    {
                      "name": "testInvalidCredentialsShowsError",
                      "description": "Invalid credentials display error message",
                      "steps": [
                        {"action": "NAVIGATE",  "value": "https://www.saucedemo.com"},
                        {"action": "FILL",       "locator": "testid=username",     "value": "invalid_user"},
                        {"action": "FILL",       "locator": "testid=password",     "value": "wrong_password"},
                        {"action": "CLICK",      "locator": "testid=login-button"},
                        {"action": "ASSERT_VISIBLE", "locator": "css=.error-message-container",
                         "description": "Verify error appears"},
                        {"action": "ASSERT_TEXT",
                         "locator": "css=.error-message-container",
                         "value": "Epic sadface",
                         "description": "Verify error message text"}
                      ]
                    }
                  ]
                }
                """;
    }

    private String sauceDemoCheckoutIntentJson() {
        return """
                {
                  "testClassName": "PROJ456_CheckoutTest",
                  "scenarios": [
                    {
                      "name": "testAddProductToCart",
                      "description": "Add Sauce Labs Backpack to cart and verify badge",
                      "steps": [
                        {"action": "NAVIGATE",      "value": "https://www.saucedemo.com"},
                        {"action": "FILL",           "locator": "testid=username",  "value": "standard_user"},
                        {"action": "FILL",           "locator": "testid=password",  "value": "secret_sauce"},
                        {"action": "CLICK",          "locator": "testid=login-button"},
                        {"action": "ASSERT_COUNT",   "locator": "css=.inventory_item", "value": "6"},
                        {"action": "CLICK",          "locator": "testid=add-to-cart-sauce-labs-backpack"},
                        {"action": "ASSERT_TEXT",    "locator": "css=.cart_badge",  "value": "1"}
                      ]
                    },
                    {
                      "name": "testCompleteCheckout",
                      "description": "Complete full checkout flow to order confirmation",
                      "steps": [
                        {"action": "NAVIGATE",   "value": "https://www.saucedemo.com"},
                        {"action": "FILL",        "locator": "testid=username",  "value": "standard_user"},
                        {"action": "FILL",        "locator": "testid=password",  "value": "secret_sauce"},
                        {"action": "CLICK",       "locator": "testid=login-button"},
                        {"action": "CLICK",       "locator": "testid=add-to-cart-sauce-labs-backpack"},
                        {"action": "CLICK",       "locator": "css=.shopping_cart_link"},
                        {"action": "CLICK",       "locator": "testid=checkout"},
                        {"action": "FILL",        "locator": "label=First Name",  "value": "Test"},
                        {"action": "FILL",        "locator": "label=Last Name",   "value": "User"},
                        {"action": "FILL",        "locator": "label=Zip/Postal Code", "value": "12345"},
                        {"action": "CLICK",       "locator": "testid=continue"},
                        {"action": "SELECT_OPTION","locator": "testid=sort-container",
                         "value": "Name (A to Z)"},
                        {"action": "CLICK",       "locator": "testid=finish"},
                        {"action": "ASSERT_VISIBLE", "locator": "css=.complete-header"},
                        {"action": "ASSERT_TEXT",    "locator": "css=.complete-header",
                         "value": "Thank you for your order!"}
                      ]
                    },
                    {
                      "name": "testCartBadgeUpdates",
                      "description": "Cart badge reflects the number of items added",
                      "steps": [
                        {"action": "NAVIGATE",       "value": "https://www.saucedemo.com"},
                        {"action": "FILL",            "locator": "testid=username",  "value": "standard_user"},
                        {"action": "FILL",            "locator": "testid=password",  "value": "secret_sauce"},
                        {"action": "CLICK",           "locator": "testid=login-button"},
                        {"action": "CLICK",           "locator": "testid=add-to-cart-sauce-labs-backpack"},
                        {"action": "CLICK",           "locator": "testid=add-to-cart-sauce-labs-bike-light"},
                        {"action": "ASSERT_TEXT",     "locator": "css=.cart_badge",  "value": "2"},
                        {"action": "ASSERT_VISIBLE",  "locator": "css=.cart_badge"}
                      ]
                    }
                  ]
                }
                """;
    }

    private String minimalValidIntentJson() {
        return """
                {
                  "testClassName": "LoginTest",
                  "scenarios": [{
                    "name": "testLogin",
                    "steps": [
                      {"action": "NAVIGATE", "value": "https://www.saucedemo.com"},
                      {"action": "ASSERT_URL", "value": ".*saucedemo.*"}
                    ]
                  }]
                }
                """;
    }

    // ════════════════════════════════════════════════════════════════════
    // Utility — render a single step wrapped in minimal valid intent
    // ════════════════════════════════════════════════════════════════════

    /**
     * Build a complete, valid TestIntent JSON with exactly one step,
     * parse it, render it, and return the Java string.
     *
     * Adds a trailing ASSERT_URL step so validation rule R10
     * (each scenario must have at least one assertion) is satisfied.
     */
    private String renderSingleStep(String action, String locator, String value) {
        return renderSingleStep(action, locator, value, null);
    }

    private String renderSingleStep(String action, String locator, String value, Integer timeout) {
        String locatorField  = locator  != null
                ? "\"locator\": \"" + locator.replace("\"", "\\\"") + "\"," : "";
        String valueField    = value    != null
                ? "\"value\": \""   + value.replace("\"", "\\\"")  + "\"," : "";
        String timeoutField  = timeout  != null
                ? "\"timeout\": " + timeout + ","                          : "";

        // Only add trailing ASSERT_URL if the step under test is NOT already an assertion
        boolean isAssertion = action.startsWith("ASSERT_");
        String trailingStep = isAssertion ? ""
                : """
                  ,
                  {"action": "ASSERT_URL", "value": ".*"}
                  """;

        String json = """
                {
                  "testClassName": "SingleStepTest",
                  "scenarios": [{
                    "name": "testSingleStep",
                    "steps": [
                      {
                        "action": "%s",
                        %s
                        %s
                        %s
                        "description": "single step under test"
                      }%s
                    ]
                  }]
                }
                """.formatted(action, locatorField, valueField, timeoutField, trailingStep);

        ParseResult result = parser.parse(json);
        assertThat(result.isSuccess())
                .as("Single step intent should parse: action=%s, %s",
                        action, result.getSummary())
                .isTrue();

        return renderer.render(result.getIntent());
    }

    /** Build intent JSON for timeout test. */
    private String intentJson(String action, String locator, String value, int timeout) {
        return """
                {
                  "testClassName": "TimeoutTest",
                  "scenarios": [{
                    "name": "testTimeout",
                    "steps": [
                      {"action": "%s", "locator": "%s", "timeout": %d},
                      {"action": "ASSERT_URL", "value": ".*"}
                    ]
                  }]
                }
                """.formatted(action, locator, timeout);
    }
}